In this project, you will implement a Manipulative DNS proxy and deploy it to Amazon Web Services.

Learning objectives
Understand the role of the Domain Name Service in the Internet's operation.
Gain experience reading network application protocol specifications, while implementing a simple DNS proxy.
Gain experience debugging network services using Wireshark.
Learn how web pages can be dynamically generated by a web server. 
Gain experience using an industry-standard cloud-computing platform.
Configure a basic firewall.
Implement a service that uses the UDP transport protocol.
About Cloud Computing
Cloud Computing basically just means renting a virtual server from a cloud computing provider such as Amazon, Microsoft, or Google.  Cloud computing became popular in the late 2000s in response to two major trends:

Software was increasing designed to run as a service, meaning that it runs entirely on remote servers (as for web-based applications) or with a significant server-side backend component (as for smartphone-based applications).  This was a departure from the earlier (1990s) model of software development where software and data lived primarily on an individual's personal computer.  Software as a service (SaaS) allows users to be more mobile -- accessing their documents and data from a variety of Internet-connected devices.
Virtualization technology allowed a single physical server to simultaneously run several isolated operating systems, thus providing the illusion of many low cost virtual machines (VMs).  You may lease a small (but reliable) VM from Amazon for $5 per month.  For most software developers this offers several types of savings, all derived from the cloud provider's economies of scale:
Many software applications require just a fraction of one machine, so the overall cost is reduced by sharing with other tenants.
There is no need for the tenant to hire IT staff capable of managing complex datacenter hardware (servers, switches, routers, power distribution systems, cooling).  Instead the tenant relies on the cloud provider's shared IT expertise.
Fault-tolerant, reliable electricity, cooling, and storage are provided transparently, without any effort on the tenant's part.  Instead the tenant uses the cloud provider's shared infrastructure.
Most of today's software is written to run in "the cloud" and so will your Project 2.

Part 1: Create a virtual server on AWS
This part is worth 10% of the points for the project.  If you work in pairs, then both partners should complete these steps (although you will only use one of the servers later).

Create an account on Amazon Web Services (Links to an external site.)Links to an external site. (AWS).  You should be able to this assignment entirely using the "free tier" of service, but you may have to pay a few dollars here and there for extra services.  Please beware that a few wrong clicks can lead to a very large bill.  So, you should not share your AWS password with your teammate.  AWS offers many services, but we will be using it's original service, called EC2 (elastic compute cloud).
Under Compute/EC2, launch a new instance.  "Instance" is EC2's term for a virtual machine.
Choose the latest "Amazon Linux AMI", which is listed first.  Here were are choosing the OS that we want pre-installed on our VM.
Choose the "t2.micro" instance size.  It should say "free tier eligible."  Choosing a larger VM can cost you a lot of money, as you can see here (Links to an external site.)Links to an external site..  (The only reason I don't suggest t2.nano is because it is not free tier eligible.)
Click "Next: Configure Instance Details."  Read the options, but do not change anything.
Click "Next: Add Storage."  Read the options, but do not change anything.
Click "Next: Add Tags."
Click "Next: Configure Security Group."
On the Security Group page, you must configure four inbound firewall rules to allow network connections from anywhere to your new machine as follows:
port 22 (for SSH), as selected by default
port 53/UDP (for DNS)
port 53/TCP (for DNS)
port 80 (for HTTP)
Click "Review and Launch," then "Launch"
Choose "Create a new key pair," download the .pem file and store it in a safe place.  You will need this to log in to your VM.  You should give a copy of this .pem file to your partner so that they too will be able to log into the machine.
Click "Launch instances" and wait a minute or so until the EC2 dashboard shows that your VM is ready.
Note the "IPv4 Public IP" address listed for your new VM in the EC2 dashboard.  You will use this when connecting to your server.
From the EC2 dashboard, click the "connect" button to see the instructions for logging into your machine with SSH.  Please be aware that your username will be "ec2-user" by default.
Log in and test that you have a working Linux environment.  You may use the "yum" command to install new software packages.  For example, run "yum list available" to see available software packages.  Then run "sudo yum install gcc-c++" to install the GNU C Compiler.
If you run into issues with your VM, please try Googling for help using the term "Amazon AMI" to identify this particular distribution of the Linux OS.  Please remember to terminate your instance after the course is completed; otherwise AWS will continue to bill you.

Deliverables:

In your README.txt, please include the public IP address of both partner's EC instances.
Part 2: UDP DNS proxy
This part is worth 40% of the points for this project.

You will write a DNS proxy server in C, C++ or Python.  A DNS proxy listens on port 53 for DNS queries, forwards those queries to a single upstream DNS resolver, waits for an answer from the upstream resolver, and forwards the answer back to the client.  Your DNS proxy will run (continuously, as a service) on the VM you set up in Part 1.  You can test your code by running it on your local machine, but you will likely have to run the code as root (administrator) because your are opening a privileged port (53 < 1024).

UDP sockets must be declared with the SOCK_DGRAM, while TCP sockets are declared are SOCK_STREAM.

References:

RFC 5625 (Links to an external site.)Links to an external site. describes how a DNS proxy should work. 
TCP/IP Illustratrated Volume 1 (Links to an external site.)Links to an external site. has a chapter on the DNS protocol.
RFC 1035 (Links to an external site.)Links to an external site. describes the basics of the DNS protocol.
A Python UDP client and server example (Links to an external site.)Links to an external site..
Simplifications for this project:

As indicated in RFC 5625 (Links to an external site.)Links to an external site., you don't really have to parse the DNS queries or answers at all to implement a proxy.  Just pass the entire query (unmodified) from client to upstream server, and pass the entire answer (unmodified) from upstream server to the client.
You may hard-code the upstream DNS resolver to be 8.8.8.8 or 8.8.4.4 (the Google public DNS servers).  In other words, you will be forwarding all client requests to the Google public DNS servers.
Requirements:

DNS occasionally operates on a TCP connection (instead of UDP), particularly when the request or response is larger than can fit in one packet.  You should just implement a UDP service for this part of the project.
Because you are not modifying the query, you should be able to handle all types of queries, like A, MX, NS, etc.
You may not use any third-party libaries to complete the assignment.  We expect you to use the BSD socket API, as in Project 1.
If you use Python, your code should work with the default version 2.7 installation that comes with the Amazon Linux AMI.
Test your DNS proxy using the nslookup command.  You will specify the IP address of the your proxy server as the resolver (as well as specifying the hostname which you are querying).  Use Wireshark (as in HW1) to debug any problems that arise.
Test your DNS proxy by changing the DNS server of your laptop to the IP address of your AWS instance.  This can be done in your OS network configuration.  Start network capture in Wireshark (as in HW1).  Whenever you visit a new website (or after you clear your DNS cache) you should see DNS queries and answer flowing between your laptop and your AWS instance.  You must verify that the IP address of the DNS server matches your AWS instance (otherwise you're not really testing it).  If your proxy server is not working, then your laptop will not be able to browse the web (except perhaps to websites whose DNS mapping have been cached locally).
The most advanced version of your DNS proxy (part 2, 3, or 4) should be running on your VM for several days after you submit your assignment.  You will have to take special steps to keep your proxy process running (in the background) even after you close your SSH session.
My favorite way to create a short-lived background process is to use the screen command.  Screen gives you a virtual terminal that you can disconnect from and leave running in the background.  For example, run "screen", then "ctrl-a d" to disconnect from the terminal.  You can log out, log back in, then type "screen -r" to reconnect to the exact same terminal.
Deliverables:

The source code for your DNS proxy, in a folder called part2 in your submission.
 A Makefile (if using C or C++) to build your proxy.
Part 3: TCP DNS Proxy
This part is worth 10% of the points for this project.

DNS also operates on TCP, particularly to handle large reponses.  Modify your proxy from Part 2 to listen to requests both on UDP and TCP.  You will need two different "accept sockets."

TCP DNS messages always begin a two byte length field (Links to an external site.)Links to an external site. telling you how much data you should read from the TCP stream.

Your proxy will always reply using the same transport protocol as the request came in.  So, answer UDP queries with UDP answers, and answer TCP queries on the same TCP connection.  There is no need to examine the responses at all.  If a large response is needed, you'll see this happen:

Client sends a UDP query
Your proxy relays the query to the upstream server and get a response.  The response says that the answer is truncated, but your proxy doesn't care.  Just relay the answer to the client.
Client should see that the answer was truncated and now send a TCP query, which you can relay to the upstream server to get a full response.
Reference:

Section 6.1.3.2 of RFC 1123 (Links to an external site.)Links to an external site.
RFC 7766 -- DNS over TCP (Links to an external site.)Links to an external site.
Requirements:

Same as for Part 2, except you should also see some DNS requests that use TCP instead of UDP.
Use the nslookup command to test a query that has a very long answer and requires TCP.  For example, the following request should try with UDP, get a truncated response, then retry the request with TCP:
On Mac/Linux:
nslookup -type=TXT long.stevetarzia.com [DNS_proxy_IP_address]
On Windows:
nslookup -querytype=TXT long.stevetarzia.com. [DNS_proxy_IP_address]
Test a query that uses TCP immediately, without trying UDP first:
On Mac/Linux, you can do this with:
$ nslookup -vc domain.com [DNS_proxy_IP_address]
On Windows:
$ nslookup "-set vc" domain.com [DNS_proxy_IP_address]
Deliverables:

The source of your TCP-enabled DNS proxy, in a folder called part3 in your submission.
A Makefile (if using C or C++) to build your proxy.
Part 4: Manipulated DNS
This part is worth 30% of the points for this project.

In the final part of this project, you are going to build on the server from Part 3, and implement a manipulative DNS proxy that gives annoying answers to certain queries.  This is actually done by some ISPs (Links to an external site.)Links to an external site. in order to earn a few advertising dollars.  The basic idea is to look for DNS queries that get no valid answer (usually caused by a typing error).  Instead of returning the "no such name" response, you will return the IP address of your AWS virtual machine.  In Part 5, you'll implement the web server that handles these requests.

References:

TCP/IP Illustratrated Volume 1 (Links to an external site.)Links to an external site. has a chapter on the DNS protocol.
RFC 1035 (Links to an external site.)Links to an external site. describes the basics of the DNS protocol.
Requirements:

Examine every DNS answer.  If it is a "no such name" response, then discard it and construct a new response with a single A record with your instance's public IP address.  (The public IP address can be a command-line parameter to your script.)  Relay the fabricated response to the client.
Do not interfere with DNS queries for valid domains.  In other words, your proxy should behave as in Part 3 for DNS queries that are not misspelled.
Test with nslookup.  For example, perform queries for both "google.com" and "lkjdsflkjwelkjflkwejkl.com".  The second should return the IP address of your server.
Windows tip: If you're testing with nslookup on Windows, please add a period after the domain name, as suggested here: https://serverfault.com/a/861547 (Links to an external site.)Links to an external site. 
Deliverables:

The source of your manupulative DNS proxy, in a folder called part4 in your submission.
 A Makefile (if using C or C++) to build your proxy.
Part 5: Advertisement server
This part is worth 10% of the points for this project.

Building off of the web servers from Project 1, implement a web server that listens on port 80 (this can be hard-coded) and serves up a dynamic html page for every GET request.  The page should be valid HTML and it must include the misspelled domain name entered by the user.  For example, your page might say "I see you were looking for caaatfood.com, but wouldn't you rather buy that from walmart.com (Links to an external site.)Links to an external site.?"  You'll find the domain name in the "Host:" header of the request.

References:

Project 1
Basic HTML (Links to an external site.)Links to an external site.
To Test:

Visit http://[VM_IP_ADDRESS] in a browser on your laptop.  You should see your dynamic page rendered in the browser.  
As above, configure your laptop to use your manipulative DNS server.
Open a browser and now visit an invalid hostname, like "jksdldkjldkjlelleeee.com"
The browser should render a webpage, served from your advertisement server, which contains the invalid domain name.  Your browser's address bar should list the domain name you typed.
Any valid URL, like google.com should work as normal, without any interference from your DNS proxy or advertisement server.
Deliverables:

The source of your HTTP advertisement server, in a folder called part5 in your submission.
 A Makefile (if using C or C++) to build your proxy.
As for the DNS proxy, please make sure that your advertisement server is running in the background on your AWS instance during the grading period.
Submission
 Not Submitted!
Submission Details
Grade: 100% (125 pts possible)
Graded Anonymously: no
Comments:
Really fantastic job.
Conor Hetland, May 31 at 10:53am